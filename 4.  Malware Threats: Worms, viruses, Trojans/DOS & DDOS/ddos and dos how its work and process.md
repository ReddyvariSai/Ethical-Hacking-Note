# **DoS & DDoS: How They Work - Complete Technical Process**

## **FUNDAMENTAL CONCEPT**
**Goal:** Make a target resource (server, network, service) unavailable to legitimate users by exhausting its resources.

---

## **THE ATTACK PROCESS: STEP-BY-STEP**

### **Phase 1: Reconnaissance & Target Selection**
```bash
# Attacker gathers information:
1. Identify target (IP/domain)
2. Determine attack surface (open ports, services)
3. Find bottlenecks (bandwidth, CPU, memory limits)
4. Identify dependencies (DNS, CDN, upstream providers)

# Example commands an attacker might use:
nmap -sS -p 1-65535 target.com          # Find open ports
traceroute target.com                    # Map network path
dig ANY target.com                       # DNS information
curl -I https://target.com               # Server headers/tech stack
```

### **Phase 2: Weaponization**
**Choosing the Right Attack Method:**

| **Target Weakness** | **Attack Method** | **Why It Works** |
|-------------------|------------------|------------------|
| Limited bandwidth | Volume-based flood | Saturates pipe |
| Stateful firewall | SYN flood | Exhausts connection tables |
| Slow application | HTTP flood | Consumes worker threads |
| Poor timeout config | Slowloris | Holds connections open |
| Vulnerable service | Exploit-based | Crashes service |

### **Phase 3: Attack Execution**

---

## **VOLUME-BASED ATTACKS (Layers 3/4)**

### **1. UDP Flood Process**
```
Attacker sends UDP packets to random ports on target

Step-by-step:
1. Attacker crafts UDP packets with spoofed source IP
2. Packets sent to target's IP address
3. Target receives packets on various ports
4. For each packet:
   - Checks which service listens on that port
   - If no service: Sends ICMP "Port Unreachable"
   - If service exists: Processes packet
5. Network bandwidth fills with:
   - Incoming attack packets
   - Outgoing ICMP responses
6. Legitimate traffic gets dropped (queue full)

Technical details:
- Packet size: 64-1514 bytes (standard Ethernet MTU)
- Rate: 100k-1M+ packets/second
- Source IPs: Often spoofed
```
```python
# Simplified UDP flood code structure
import socket
import random

def udp_flood(target_ip, target_port, duration):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    bytes = random._urandom(1024)  # Random payload
    
    timeout = time.time() + duration
    while time.time() < timeout:
        # Send to random ports to confuse target
        port = random.randint(1, 65535)
        sock.sendto(bytes, (target_ip, port))
    
    sock.close()
```

### **2. ICMP (Ping) Flood**
```
Uses ICMP Echo Request (ping) packets

Process:
1. Attacker sends continuous ICMP Echo Requests
2. Target must respond with ICMP Echo Reply for each
3. Consumes:
   - Incoming bandwidth (requests)
   - Outgoing bandwidth (replies)
   - CPU cycles to process ICMP
4. Amplification: Each request generates a reply

Modern impact: Less effective due to:
- ICMP rate limiting on modern OS
- Firewalls blocking ICMP
- Limited packet size (typically 64 bytes)
```

### **3. Amplification Attacks**
```
MOST DANGEROUS - Small request → Huge response

Process (DNS Amplification Example):
1. Attacker spoofs source IP = Target's IP
2. Attacker sends small DNS query to open resolvers
   Query size: ~60 bytes
3. Resolver sends response to spoofed IP (the target)
   Response size: ~3000 bytes (50x amplification)
4. Target receives massive DNS responses
5. Bandwidth saturated

Common amplifiers:
- DNS (50-54x)
- NTP (556x with MONLIST)
- Memcached (50,000x+)
- SSDP (30x)
- SNMP (6.3-70x)
```

---

## **PROTOCOL ATTACKS (Layers 3/4)**

### **1. SYN Flood - The Classic Attack**
```
Exploits TCP 3-way handshake

Normal TCP Connection:
Client               Server
  |---- SYN ------>|
  |<--- SYN-ACK ---|
  |---- ACK ------>|
  (Connection established)

SYN Flood Attack:
Attacker (spoofed IPs)     Server
  |---- SYN [IP1] ------>|
  |---- SYN [IP2] ------>|
  |---- SYN [IP3] ------>|
  |---- SYN [IP4] ------>|
  (Thousands per second)
  
Server responds to each:
  |<--- SYN-ACK [to IP1] ---
  |<--- SYN-ACK [to IP2] ---
  |<--- SYN-ACK [to IP3] ---
  
But ACK never comes back!
Result: "Half-open connections" fill connection table
```
```c
// Server-side connection table fills
struct tcp_connection {
    uint32_t src_ip;
    uint32_t dst_ip;
    uint16_t src_port;
    uint16_t dst_port;
    enum state;  // SYN_RECEIVED (waiting for ACK)
    timer_t timeout;  // 30-75 seconds default
};

// When table is full:
if (connection_count >= MAX_CONNECTIONS) {
    drop_new_connections();  // Legitimate users can't connect
}
```

### **2. ACK & PUSH+ACK Floods**
```
More sophisticated TCP state attacks:

ACK Flood:
- Sends TCP packets with ACK flag set
- Forces target to search connection table
- CPU exhaustion from state validation

PUSH+ACK Flood:
- Sends data with PUSH flag
- Forces immediate buffer processing
- Consumes interrupt cycles
```

### **3. Fragmentation Attacks**
```
Sends fragmented IP packets that can't be reassembled

Process:
1. Attacker sends packet fragments
2. Target stores fragments in buffer (waiting for all)
3. Attacker never sends final fragment
4. Buffer fills with incomplete packets
5. Legitimate fragmented traffic gets dropped

Modern relevance: Less effective due to:
- Better fragment handling in kernels
- IDS/IPS detection
```

---

## **APPLICATION LAYER ATTACKS (Layer 7)**

### **1. HTTP/HTTPS Flood**
```
"Looks like legitimate traffic"

Process:
1. Attacker establishes many HTTP connections
2. Sends complete, valid HTTP requests
   GET /large-image.jpg HTTP/1.1
   Host: target.com
   User-Agent: [Legitimate browser]
   
3. Target processes each request:
   - Parses headers
   - Executes application logic
   - Generates response
   - Sends response

4. Resources consumed:
   - Web server workers (Apache: 256 max by default)
   - Database connections
   - CPU for dynamic content
   - Bandwidth for responses
   
5. Legitimate users get "Server too busy"
```

### **2. Slowloris Attack (The Silent Killer)**
```
Holds connections open with minimal traffic

Process:
1. Attacker opens many connections
   GET / HTTP/1.1\r\n
   Host: target.com\r\n
   User-Agent: Mozilla\r\n
   (NO \r\n\r\n to end headers yet)

2. Sends header lines slowly:
   Time 0s: "GET / HTTP/1.1\r\n"
   Time 10s: "Host: target.com\r\n"
   Time 20s: "User-Agent: Mozilla\r\n"
   Time 30s: "X-a: b\r\n" (additional header)

3. Server keeps connection alive (waiting for end)
4. Connection pool fills (Apache: default 256)
5. New users get connection refused
```
```python
# Slowloris conceptual code
import socket
import time

def slowloris_connection(target, port):
    sock = socket.socket()
    sock.connect((target, port))
    
    # Send initial headers
    sock.send(b"GET / HTTP/1.1\r\n")
    sock.send(b"Host: " + target.encode() + b"\r\n")
    
    # Keep connection alive
    while True:
        sock.send(b"X-a: b\r\n")  # Fake header
        time.sleep(10)  # Wait 10 seconds
        # Connection stays open
```

### **3. Slow POST Attack**
```
Similar to Slowloris, but with POST data

Process:
1. POST /login HTTP/1.1
2. Content-Length: 1000000  (Declare 1MB body)
3. Send body very slowly: 1 byte every 10 seconds
4. Server allocates 1MB buffer, waits for all data
5. Worker thread stuck waiting
```

### **4. HTTP/2 Rapid Reset (CVE-2023-44487)**
```
Newer, devastating attack (2023)

Process:
1. Establish HTTP/2 connection
2. Send thousands of request streams
3. Immediately send RST_STREAM to cancel
4. Server must:
   - Allocate resources for each request
   - Process cancellation
   - Clean up resources
5. Repeat rapidly
6. CPU exhaustion from setup/teardown cycles

Impact: Can overwhelm with minimal bandwidth
```

---

## **DDoS SPECIFIC: THE BOTNET PROCESS**

### **Step 1: Botnet Creation**
```
1. Infection: Malware spreads (IoT, servers, PCs)
   - Mirai: Telnet/SSH brute force
   - Emotet: Phishing emails
   - Drive-by downloads

2. Command & Control (C2) setup:
   Centralized: IRC, HTTP server
   P2P: Bots communicate directly
   Hybrid: Multiple C2 with fallbacks

3. Bot registration:
   Bot → C2: "I'm alive at IP X, capacity Y"
   C2 maintains bot list
```

### **Step 2: Attack Coordination**
```
C2 sends commands to bots:

Format: !attack <target> <port> <time> <method>
Example: !attack 203.0.113.1 80 300 HTTP

Bots receive command and:
1. Parse attack parameters
2. Start attack threads
3. Report status to C2
4. Stop after duration expires
```

### **Step 3: Attack Scaling**
```
Why DDoS > DoS:

1. Distribution:
   10,000 bots × 1 Mbps = 10 Gbps attack
   Each bot uses home/office bandwidth
   Hard to block (many source IPs)

2. Persistence:
   If some bots blocked, others continue
   Bots can switch attack methods

3. Evasion:
   Bots mimic legitimate traffic
   Randomize source ports, patterns
   Use legitimate user-agents
```

---

## **TARGET'S PERSPECTIVE: WHAT HAPPENS DURING ATTACK**

### **Network Level Impact:**
```
[ Internet ] → [ Router/Firewall ] → [ Server ]
       ↑                ↑                  ↑
   Attack traffic   Queue fills      Resource exhaustion

1. Router/Firewall:
   - Connection table fills
   - Packet buffers overflow
   - CPU spikes from packet processing
   - May crash or reboot

2. Bandwidth saturation:
   [Normal: 20% utilization]
   [Attack: 100% utilization]
   Result: Packet loss, increased latency

3. ISP upstream:
   - May null-route target IP (blackhole)
   - To protect their network
   - Makes target unreachable to EVERYONE
```

### **Server Level Impact:**
```bash
# What admin sees during attack:

# High CPU usage
top - 13:45:00 up 10 days, load average: 50.21, 48.76, 42.11
PID USER    PR  NI  VIRT  RES  SHR S %CPU %MEM   TIME+  COMMAND
1234 www-data 20   0  2.3g 1.2g 100m R 99.6 15.3 100:30.34 apache2

# Network saturation
$ iftop
interface: eth0
13:45:00              ↓ 1.5 Gbps          ↑ 1.4 Gbps
                      total: 2.9 Gbps (interface max: 1 Gbps)

# Connection overload
$ netstat -nt | wc -l
25000  # Thousands of connections

$ ss -s
Total: 25000 (kernel 30000)
TCP:   24000 (estab 100, closed 23900, orphaned 200)

# Memory exhaustion
$ free -h
              total used free
Mem:           16G  16G 100M  # No free memory
Swap:          4G   4G   0B   # Swap full too

# Disk I/O from logging
$ iotop
Total DISK READ: 150 MB/s | Total DISK WRITE: 200 MB/s
```

### **Application Level Impact:**
```
Web Server (Apache/Nginx):
- Worker processes all busy
- New connections queued or dropped
- Error log: "server reached MaxClients setting"
- May spawn more processes until memory exhausted

Database:
- Connection pool exhausted
- Slow queries from resource contention
- Replication lag
- May crash or stall

Load Balancer:
- Health checks fail
- Marks servers as down
- May overload remaining servers

CDN:
- Origin shield overwhelmed
- Cache misses increase
- May start passing all traffic to origin
```

---

## **MODERN ATTACK EVOLUTIONS**

### **1. Multi-Vector Attacks**
```
Combine multiple techniques:

Example attack:
1. Start with SYN flood (exhaust firewall)
2. Add HTTP flood (bypass SYN protection)
3. Mix with slowloris (different detection)
4. Finish with DNS amplification (max damage)

Defense must handle ALL attack types simultaneously
```

### **2. AI-Powered Attacks**
```
Machine learning used to:
- Learn target's normal patterns
- Mimic legitimate user behavior
- Adapt to defenses in real-time
- Find optimal attack parameters

Example: Vary request patterns based on target response
```

### **3. IoT Botnet Scale**
```
Mirai-style botnets:
- Default/weak credentials on devices
- Cameras, routers, DVRs, IoT devices
- Global distribution
- Always-on connectivity
- Difficult to clean (users unaware)

2024: 5G devices increase potential scale
```

### **4. Application-Specific Attacks**
```
Target weaknesses in specific apps:

WordPress:
- XML-RPC pingback attacks
- wp-comments-post.php floods
- Search function exhaustion

API Endpoints:
- Expensive queries (JOINs, full scans)
- Authentication endpoint floods
- Webhook callback storms
```

---

## **THE COMPLETE ATTACK TIMELINE**

### **T-24 Hours: Preparation**
```
1. Build/rent botnet (100,000 bots @ $200/day)
2. Reconnaissance (find target weaknesses)
3. Test small-scale (verify attack works)
4. Setup monitoring (track target status)
```

### **T-0: Attack Launch**
```
00:00 - Phase 1: SYN flood (test defenses)
00:05 - Phase 2: Add UDP flood (increase volume)
00:10 - Phase 3: HTTP flood (bypass L3 filters)
00:15 - Phase 4: DNS amplification (max damage)
00:20 - All vectors simultaneously
```

### **T+30 Minutes: Target Response**
```
Target tries to mitigate:
00:30 - Firewall rules added (block IP ranges)
00:35 - Rate limiting enabled
00:40 - Contact ISP for help
00:45 - Enable cloud DDoS protection
01:00 - Some mitigation effective
```

### **T+2 Hours: Attack Adaptation**
```
Attacker observes defenses:
- Cloudflare enabled? Switch to direct IP
- Rate limiting per IP? Distribute across more bots
- IP blocking? Use more spoofed IPs
- Continue for hours/days
```

### **T+End: Attack Stops**
```
Reasons to stop:
1. Extortion paid (if ransomware DDoS)
2. Target fully protected (attack ineffective)
3. Botnet taken down (law enforcement)
4. Attacker moves to new target
```

---

## **TECHNICAL DEFENSE MECHANISMS**

### **How Defenses Work:**
```
1. Traffic Filtering:
   - BGP Flowspec: ISP-level filtering
   - ACLs: Block known bad IPs
   - Rate limiting: X requests/second per IP

2. Anomaly Detection:
   Baseline: Normal traffic patterns
   Alert: Deviation from baseline
   Action: Trigger mitigation

3. Scrubbing Centers:
   All traffic → Scrubbing center → Clean traffic → Target
   Attack traffic detected and dropped

4. Anycast DNS:
   Distribute attack across global network
   Each location absorbs portion of attack
```

### **The Arms Race:**
```
Attackers innovate → Defenders adapt → Cycle repeats

2000s: SYN floods → SYN cookies invented
2010s: Amplification attacks → ISPs filter spoofed traffic
2020s: AI attacks → AI defenses
Future: Quantum computing attacks → Quantum encryption
```

---

## **KEY TAKEAWAYS**

### **1. Resource Exhaustion is the Goal**
```
Attackers target the weakest link:
- Bandwidth (pipe size)
- Connection tables (memory)
- CPU (processing power)
- Application workers (threads)
- Database connections (pools)
```

### **2. Scale Makes the Difference**
```
DoS: 1 source → Easily blocked
DDoS: 100,000 sources → Extremely difficult
```

### **3. Legitimate-Looking Attacks Are Most Dangerous**
```
Volume attacks: Easy to detect, hard to stop
Application attacks: Hard to detect, easier to stop (if identified)
```

### **4. The Internet Wasn't Designed for This**
```
TCP/IP assumes good actors
No built-in sender verification
Amplification possible by design
```

### **5. Defense is Multi-Layered**
```
No single solution works
Requires: ISP + On-prem + Cloud + Application defenses
```

**Understanding these processes is crucial for both defense and forensic analysis after an attack.** The complexity continues to evolve as both attackers and defenders develop new techniques.
